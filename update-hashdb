#!/usr/bin/env python3

import argparse
import hashlib
import os
import pathlib
import sqlite3


def setup_db(cur: sqlite3.Cursor):
    cur.executescript("""
        PRAGMA foreign_keys = ON;
        CREATE TABLE IF NOT EXISTS paths(
            id INTEGER PRIMARY KEY,
            path STRING UNIQUE NOT NULL
        );
        CREATE TABLE IF NOT EXISTS hashes(
            path_id INTEGER NOT NULL,
            hash_type STRING NOT NULL,
            hash_value STRING NOT NULL,
            FOREIGN KEY(path_id) REFERENCES paths(id) ON DELETE CASCADE,
            PRIMARY KEY(path_id, hash_type)
        ) WITHOUT ROWID;
    """)


def get_path_id(cur: sqlite3.Cursor, path: str) -> int | None:
    cur.execute("SELECT id FROM paths WHERE path = ?", (path,))
    if (ret := cur.fetchone()) is not None: return ret[0]
    return None


def insert_path(cur: sqlite3.Cursor, path: pathlib.Path) -> int:
    cur.execute("INSERT INTO paths(path) VALUES(?)", (str(path),))
    return cur.lastrowid


def found_hashes(cur: sqlite3.Cursor, path_id: int) -> set[str]:
    cur.execute("SELECT hash_type FROM hashes WHERE path_id = ?", (path_id,))
    return {row[0] for row in cur.fetchall()}


def insert_hash(cur: sqlite3.Cursor, path_id: int, hashname: str, val: bytes):
    cur.execute(
        "INSERT INTO hashes(path_id, hash_type, hash_value) VALUES(?, ?, ?)",
        (path_id, hashname, val,))
    assert cur.rowcount == 1


def hash_file(path: pathlib.Path, hashes: [str]) -> dict[str, bytes]:
    hashers = {h: hashlib.new(h) for h in hashes}
    def update(block: str):
        for hasher in hashers.values(): hasher.update(block)

    with open(path, "rb") as f:
        while block := f.read(4096): update(block)

    return {key: val.digest() for key, val in hashers.items()}


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument("-b", "--basedir", type=pathlib.Path, default=None)
    parser.add_argument("-t", "--hashtypes", type=str, action="append")
    parser.add_argument("db", type=pathlib.Path)
    ret = parser.parse_args()
    if ret.basedir is None: ret.basedir = ret.db.parent
    if ret.hashtypes is None: ret.hashtypes = ["sha512", "blake2b", "sha3-512"]
    return ret


def walk_dir(path: pathlib.Path):
    for cur, dirs, files in os.walk(path):
        curdir = pathlib.Path(cur)
        prefix = curdir.relative_to(path)
        yield from map(prefix.joinpath, files)


def hash_new(cur: sqlite3.Cursor,
             basedir: pathlib.Path,
             hashes: set[str],
             remove: set[pathlib.Path]):
    removes_abspaths = set(map(pathlib.Path.absolute, remove))

    def new_files():
        for stem in walk_dir(basedir):
            abspath = (basedir / stem).absolute()
            if abspath in removes_abspaths: continue
            path_id = get_path_id(cur, str(stem))
            needed = set(hashes)
            if path_id is not None: needed -= found_hashes(cur, path_id)
            if not needed: continue
            yield stem, path_id, needed

    def key(row):
        name = row[0].name
        return name[0].isdigit(), name, row[0]

    for stem, path_id, needed in sorted(new_files(), key=key):
        new_hashes = hash_file(basedir / stem, needed)
        if path_id is None: path_id = insert_path(cur, stem)
        for hash_name, hash_val in new_hashes.items():
            print(f"{hash_val.hex()} [{hash_name:7}] {stem}")
            insert_hash(cur, path_id, hash_name, hash_val)


def main(args: argparse.Namespace):
    db_file = args.db.absolute()
    journal = pathlib.Path(f"{db_file}-journal")
    with sqlite3.connect(args.db, autocommit=False) as db:
        setup_db(db.cursor())
        hash_new(db.cursor(),
                 args.basedir,
                 set(args.hashtypes),
                 {db_file, journal})
        db.commit()


if __name__ == "__main__":
    main(parse_args())
